#!/usr/bin/env ruby

# *************************************************************************** #
#                                  LOAD PATHS                                 #
# *************************************************************************** #
begin
  # Bundler dependencies
  require 'rubygems'
  require 'bundler/setup'

  require 'pry-byebug'

  require 'observer'

  # Setup load path for application (makes you realise RubyGems spoils you...)
  lib_path = File.expand_path(File.dirname(__FILE__) + '/../lib')
  ext_path = File.expand_path(File.dirname(__FILE__) + '/../ext')
  $LOAD_PATH.unshift(lib_path) unless $LOAD_PATH.include?(lib_path)
  $LOAD_PATH.unshift(ext_path) unless $LOAD_PATH.include?(ext_path)

  require 'log_actually'
  LogActually.is_all_around(:interface)
  LogActually.interface.i
  LogActually.is_all_around(:datalink)
  LogActually.datalink.i
  LogActually.is_all_around(:multiplexer)
  LogActually.multiplexer.i
  LogActually.is_all_around(:demultiplexer)
  LogActually.demultiplexer.i
  LogActually.is_all_around(:transmitter)
  LogActually.transmitter.i
  LogActually.is_all_around(:virtual)
  LogActually.virtual.i
  LogActually.is_all_around(:parameterized)
  LogActually.parameterized.i

  # Virtual Devices
  LogActually.is_all_around(:api)
  LogActually.api.i

  LogActually.is_all_around(:cdc)
  LogActually.cdc.i
  LogActually.is_all_around(:rad)
  LogActually.rad.i
  LogActually.is_all_around(:gfx)
  LogActually.gfx.i
  LogActually.is_all_around(:bmbt)
  LogActually.bmbt.i

  # Abstraction
  LogActually.is_all_around(:display)
  LogActually.display.d

  # Yabber
  LogActually.is_all_around(:messaging)
  LogActually.messaging.i
  LogActually.is_all_around(:client)
  LogActually.client.i
  LogActually.is_all_around(:publisher)
  LogActually.publisher.i
  LogActually.is_all_around(:server)
  LogActually.server.i
  LogActually.is_all_around(:subscriber)
  LogActually.subscriber.i

  # Wolfgang
  LogActually.is_all_around(:notify)
  LogActually.notify.i
  LogActually.is_all_around(:alive)
  LogActually.alive.i
  LogActually.is_all_around(:ui)
  LogActually.ui.i
  LogActually.is_all_around(:wolfgang)
  LogActually.wolfgang.d

  LOGGER = LogActually.is_all_around(:default)
  LOGGER.i

  require 'helpers/manageable_threads'
  require 'yabber/yabber'
rescue LoadError => e
  # LogActually.default.error('run') { e }
  puts e
  e.backtrace.each { |line| puts line }
  $LOAD_PATH.each { |line| puts line }
  exit
rescue StandardError => e
  puts e
  e.backtrace.each { |line| puts line }
  exit
end

# *************************************************************************** #
#                                 APPLICATION                                 #
# *************************************************************************** #

PROC = 'Walter'.freeze

LOGGER.info(PROC) { "BMW I/K-BUS Interface" }

begin
  require 'walter'
  app = Walter.new
  app.launch
rescue Interrupt
  Signal.trap(0, proc { puts "Terminating: #{$$}" })
  LOGGER.close
  return 1
rescue LoadError => e
  LOGGER.error('run') { 'Application LoadError' }
  LOGGER.error('run') { e }
  e.backtrace.each { |line| LOGGER.warn('run') { line } }
  # $LOAD_PATH.each { |line| LOGGER.warn('run') { line } }
  exit(false)
rescue StandardError => e
  LOGGER.error('run') { 'Rescued at bin/run' }
  LOGGER.error('run') { e }
  e.backtrace.each { |line| LOGGER.error('run') { line } }
  LOGGER.close
  exit(false)
rescue SystemExit
  puts "rescued a SystemExit exception"
end

return 0
